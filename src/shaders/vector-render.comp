#version 450 core

#define LINE_WIDTH 5

struct Edge {
    vec3 start;
    vec3 control1;
    vec3 control2;
    vec3 end;
};

layout(std430, binding = 2) readonly buffer Edges {
    Edge edges[];
};

layout (rgba32f, binding = 3) writeonly uniform image2D outputImage;

vec2 bezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {
    float u = 1.0 - t;
    return u*u*u * p0 +
           3.0*u*u*t * p1 +
           3.0*u*t*t * p2 +
           t*t*t * p3;
}

bool isPointNearBezier(vec2 pt, vec2 p0, vec2 p1, vec2 p2, vec2 p3, float threshold) {
    float minDistSq = 1e10;
    const int NUM_SAMPLES = 32;
    for (int i = 0; i <= NUM_SAMPLES; ++i) {
        float t = float(i) / float(NUM_SAMPLES);
        vec2 b = bezier(p0, p1, p2, p3, t);
        float distSq = dot(pt - b, pt - b);
        minDistSq = min(minDistSq, distSq);
    }
    return minDistSq <= threshold * threshold;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);

    for (int i = 0; i < edges.length(); i++) {

        vec2 point = pixelCoords / size * 2.0 - 1.0;
        vec2 cp0 = edges[i].start.xy;
        vec2 cp1 = edges[i].control1.xy;
        vec2 cp2 = edges[i].control2.xy;
        vec2 cp3 = edges[i].end.xy;
        float threshold = 0.05;

        bool hit = isPointNearBezier(point, cp0, cp1, cp2, cp3, threshold);

        if (hit) {
            vec4 color = vec4(0.0, 0.0, 0.0, 1.0);
            imageStore(outputImage, pixelCoords, color);
        }
    }

}