#version 450 core

#define LINE_WIDTH 0.005

struct Edge {
    vec3 start;
    vec3 control1;
    vec3 control2;
    vec3 end;
};

layout(std140, binding = 0) uniform Scene {
    mat4  view;
    mat4  projection;
    vec3  cameraPosition;
} sb;

layout(std430, binding = 2) readonly buffer Edges {
    Edge edges[];
};

layout (rgba32f, binding = 3) uniform image2D outputImage;

vec3 bezier(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {
    float u = 1.0 - t;
    float tt = t * t;
    float uu = u * u;
    float uuu = uu * u;
    float ttt = tt * t;

    vec3 point = uuu * p0;              // (1 - t)^3 * p0
    point += 3.0 * uu * t * p1;         // 3 * (1 - t)^2 * t * p1
    point += 3.0 * u * tt * p2;         // 3 * (1 - t) * t^2 * p2
    point += ttt * p3;                  // t^3 * p3

    return point;
}

float distanceToSegment(vec2 p0, vec2 p1, vec2 p) {

    float m = p0.x - p1.x;

    if (m == 0) {
        m = 9999;
    } else {
        m = (p0.y - p1.y) / m;
    }

    

    float num = m*(-m*p0.x + p0.y - p.y) - p.x;
    float denom = m*m + 1.0;

    float x = clamp(-num / denom, min(p1.x, p0.x), max(p1.x, p0.x));
    float y = m * (x - p0.x) + p0.y;

    float dx = x - p.x;
    float dy = y - p.y;

    return dx*dx + dy*dy;
}

bool isPointNearBezier(vec2 pt, vec3 p0, vec3 p1, vec3 p2, vec3 p3) {

    float mindist = 99999;
    float t = 0;

    vec3 prev = bezier(p0, p1, p2, p3, t);

    const int segments = 10;

    for (int i = 1; i < segments + 1; i++) {
        vec3 pres = bezier(p0, p1, p2, p3, float(i) / float(segments));

        float d = distanceToSegment(pres.xy, prev.xy, pt);

        if (d < mindist) {
            mindist = d;
            t = float(i) / float(segments);
        }

        prev = pres;
    }

    prev = bezier(p0, p1, p2, p3, t);

    if (prev.z > 1.0 || prev.z < 0.0) {
        return false;
    }

    return mindist <= LINE_WIDTH*LINE_WIDTH;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);

    vec2 point = vec2(pixelCoords) / vec2(size) * 2.0 - 1.0;

    for(int i = 0; i < edges.length(); i++) {

        float minx = min(min(edges[i].start.x, edges[i].control1.x), min(edges[i].control2.x, edges[i].end.x));

        if (point.x < minx - LINE_WIDTH*2) {
            continue;
        }

        float miny = min(min(edges[i].start.y, edges[i].control1.y), min(edges[i].control2.y, edges[i].end.y));

        if (point.y < miny - LINE_WIDTH*2) {
            continue;
        }

        float maxx = max(max(edges[i].start.x, edges[i].control1.x), max(edges[i].control2.x, edges[i].end.x));

        if (point.x > maxx + LINE_WIDTH*2) {
            continue;
        }

        float maxy = max(max(edges[i].start.y, edges[i].control1.y), max(edges[i].control2.y, edges[i].end.y));

        if (point.y > maxy + LINE_WIDTH*2) {
            continue;
        }

        bool hit = isPointNearBezier(point, edges[i].start, edges[i].control1, edges[i].control2, edges[i].end);

        if (hit) {
            vec4 color = vec4(0.0, 0.0, 0.0, 1.0);
            vec4 srcColor = imageLoad(outputImage, pixelCoords);

            vec4 newColor = (1 - color.a) * srcColor + color;

            imageStore(outputImage, pixelCoords, newColor);
        }

    }
}